Анонимные функции

Иногда именованию функции не стоит уделять особого внимания. Например, если вы уверены, что она будет использована только раз. Для таких случаев Python предлагает применять анонимные функции, также называемые лямбда-функциями.

Лямбда-функция может быть назначена переменной, создавая краткий способ определения функции:
>>> add_one = lambda x: x + 1
>>> add_one(3)
4

Это становится более интересным, когда необходимо использовать функцию в качестве аргумента. В таких случаях она часто используется только один раз. Как известно, map применяет функцию ко всем элементам итерируемого объекта. Мы можем использовать лямбду при вызове map:        
>>> numbers = [1, 2, 3, 4]
>>> times_two = map(lambda x: x * 2, numbers)
>>> list(times_two)
[2, 4, 6, 8]

Этот кусок кода встречается часто. Например, когда требуется применить операцию к каждому элементу итеративного объекта. В данной ситуации использование map() в сочетании с лямбда-функцией является кратким и эффективным.
****************************************************************************************************
List Comprehensions

List comprehension может заменить неэстетичные циклы, используемые для заполнения списка. Синтаксис выглядит следующим образом:        
[ expression for item in list if conditional ]

Простейший пример заполнения списка последовательностью чисел:
mylist = [i for i in range(10)]
print(mylist)
# [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

Поскольку здесь можно использовать выражения, вам доступна работа с математикой:
squares = [x**2 for x in range(10)]
print(squares)
# [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

Вызов внешней функции:        
def some_function(a):
    return (a + 5) / 2
    
my_formula = [some_function(i) for i in range(10)]
print(my_formula)
# [2.5, 3.0, 3.5, 4.0, 4.5, 5.0, 5.5, 6.0, 6.5, 7.0]

И, наконец, вы сможете использовать «if» для фильтрации списка. В этом случае будут сохранены только те значения, которые делятся на 2:    
filtered = [i for i in range(20) if i%2==0]
print(filtered)
# [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]

****************************************************************************************************
Замена переменных на месте

Этот аккуратный трюк поможет сэкономить несколько строк кода:        
a = 1
b = 2
a, b = b, a
print (a)
# 2
print (b)
# 1
****************************************************************************************************
Nested list comprehensions

Помните основной синтаксис list comprehensions?
[ expression for item in list if conditional ]

Если expression может быть любым валидным выражением Python, оно также может быть и другим list comprehension. Это полезно, когда необходимо создать матрицу:
[[j for j in range(3)] for i in range(4)]
[[0, 1, 2], [0, 1, 2], [0, 1, 2], [0, 1, 2]]

Или, если хотите «разгладить» предыдущую матрицу:        
>>> [value
      for sublist in m
      for value in sublist]
[0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2]

Первая часть цикла по матрице m, а вторая – цикл по элементам каждого вектора.
****************************************************************************************************
Использование подчеркивания в REPL

Вы можете получить результат последнего выражения в Python REPL с помощью оператора подчеркивания, например, в Python REPL это выглядит следующим образом:
>>> 3 * 3
9
>>> _ + 3
12
****************************************************************************************************
Возврат нескольких значений

Функции в Python могут возвращать более одной переменной без применения словаря, списка или класса. Это работает так:
        
def get_user(id):
    # fetch user from database
    # ....
    return name, birthdate

name, birthdate = get_user(4)

Здесь возвращается кортеж. С тем же эффектом можно было бы написать return (name, birthdate).
Это нормально для ограниченного количества возвращаемых значений. Но все, что превышает 3 значения, должно быть помещено в класс (data).

****************************************************************************************************
Объединение словарей

Начиная с Python 3.5, стало проще объединять словари.
        
dict1 = { 'a': 1, 'b': 2 }
dict2 = { 'b': 3, 'c': 4 }
merged = { **dict1, **dict2 }

print (merged)
# {'a': 1, 'b': 3, 'c': 4}

# Python >= 3.9 only
merged = dict1 | dict2

print (merged)
# {'a': 1, 'b': 3, 'c': 4}

Если встречаются дублирующиеся ключи – в первом словаре они будут перезаписаны.

****************************************************************************************************
Нарезка списка

Синтаксис нарезания таков:
a[start:stop:step]

Start, stop и step необязательны. У них есть дефолтные значения, которые активируются, если не заполнить параметры:
    0 для start;
    конец списка для stop;
    1 для step.

Вот несколько примеров:        
# We can easily create a new list from 
# the first two elements of a list:
first_two = [1, 2, 3, 4, 5][0:2]
print(first_two)
# [1, 2]

# And if we use a step value of 2, 
# we can skip over every second number
# like this:
steps = [1, 2, 3, 4, 5][0:5:2]
print(steps)
# [1, 3, 5]

# This works on strings too. In Python,
# you can treat a string like a list of
# letters:
mystring = "abcdefdn nimt"[::2]
print(mystring)
# 'aced it'

****************************************************************************************************

****************************************************************************************************

****************************************************************************************************

****************************************************************************************************
