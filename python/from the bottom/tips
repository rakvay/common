Анонимные функции

Иногда именованию функции не стоит уделять особого внимания. Например, если вы уверены, что она будет использована только раз. Для таких случаев Python предлагает применять анонимные функции, также называемые лямбда-функциями.

Лямбда-функция может быть назначена переменной, создавая краткий способ определения функции:
>>> add_one = lambda x: x + 1
>>> add_one(3)
4

Это становится более интересным, когда необходимо использовать функцию в качестве аргумента. В таких случаях она часто используется только один раз. Как известно, map применяет функцию ко всем элементам итерируемого объекта. Мы можем использовать лямбду при вызове map:        
>>> numbers = [1, 2, 3, 4]
>>> times_two = map(lambda x: x * 2, numbers)
>>> list(times_two)
[2, 4, 6, 8]

Этот кусок кода встречается часто. Например, когда требуется применить операцию к каждому элементу итеративного объекта. В данной ситуации использование map() в сочетании с лямбда-функцией является кратким и эффективным.
****************************************************************************************************
List Comprehensions

List comprehension может заменить неэстетичные циклы, используемые для заполнения списка. Синтаксис выглядит следующим образом:        
[ expression for item in list if conditional ]

Простейший пример заполнения списка последовательностью чисел:
mylist = [i for i in range(10)]
print(mylist)
# [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

Поскольку здесь можно использовать выражения, вам доступна работа с математикой:
squares = [x**2 for x in range(10)]
print(squares)
# [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

Вызов внешней функции:        
def some_function(a):
    return (a + 5) / 2
    
my_formula = [some_function(i) for i in range(10)]
print(my_formula)
# [2.5, 3.0, 3.5, 4.0, 4.5, 5.0, 5.5, 6.0, 6.5, 7.0]

И, наконец, вы сможете использовать «if» для фильтрации списка. В этом случае будут сохранены только те значения, которые делятся на 2:    
filtered = [i for i in range(20) if i%2==0]
print(filtered)
# [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]

****************************************************************************************************
Замена переменных на месте

Этот аккуратный трюк поможет сэкономить несколько строк кода:        
a = 1
b = 2
a, b = b, a
print (a)
# 2
print (b)
# 1
****************************************************************************************************
Nested list comprehensions

Помните основной синтаксис list comprehensions?
[ expression for item in list if conditional ]

Если expression может быть любым валидным выражением Python, оно также может быть и другим list comprehension. Это полезно, когда необходимо создать матрицу:
[[j for j in range(3)] for i in range(4)]
[[0, 1, 2], [0, 1, 2], [0, 1, 2], [0, 1, 2]]

Или, если хотите «разгладить» предыдущую матрицу:        
>>> [value
      for sublist in m
      for value in sublist]
[0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2]

Первая часть цикла по матрице m, а вторая – цикл по элементам каждого вектора.
****************************************************************************************************
Использование подчеркивания в REPL

Вы можете получить результат последнего выражения в Python REPL с помощью оператора подчеркивания, например, в Python REPL это выглядит следующим образом:
>>> 3 * 3
9
>>> _ + 3
12
****************************************************************************************************
Возврат нескольких значений

Функции в Python могут возвращать более одной переменной без применения словаря, списка или класса. Это работает так:
        
def get_user(id):
    # fetch user from database
    # ....
    return name, birthdate

name, birthdate = get_user(4)

Здесь возвращается кортеж. С тем же эффектом можно было бы написать return (name, birthdate).
Это нормально для ограниченного количества возвращаемых значений. Но все, что превышает 3 значения, должно быть помещено в класс (data).

****************************************************************************************************
Объединение словарей

Начиная с Python 3.5, стало проще объединять словари.
        
dict1 = { 'a': 1, 'b': 2 }
dict2 = { 'b': 3, 'c': 4 }
merged = { **dict1, **dict2 }

print (merged)
# {'a': 1, 'b': 3, 'c': 4}

# Python >= 3.9 only
merged = dict1 | dict2

print (merged)
# {'a': 1, 'b': 3, 'c': 4}

Если встречаются дублирующиеся ключи – в первом словаре они будут перезаписаны.

****************************************************************************************************
Нарезка списка

Синтаксис нарезания таков:
a[start:stop:step]

Start, stop и step необязательны. У них есть дефолтные значения, которые активируются, если не заполнить параметры:
    0 для start;
    конец списка для stop;
    1 для step.

Вот несколько примеров:        
# We can easily create a new list from 
# the first two elements of a list:
first_two = [1, 2, 3, 4, 5][0:2]
print(first_two)
# [1, 2]

# And if we use a step value of 2, 
# we can skip over every second number
# like this:
steps = [1, 2, 3, 4, 5][0:5:2]
print(steps)
# [1, 3, 5]

# This works on strings too. In Python,
# you can treat a string like a list of
# letters:
mystring = "abcdefdn nimt"[::2]
print(mystring)
# 'aced it'
****************************************************************************************************
Использование памяти

С помощью sys.getsizeof() можно проверить использование памяти объектом:

import sys

mylist = range(0, 10000)
print(sys.getsizeof(mylist))
# 48

Огромный список всего 48 байт, потому что функция range возвращает класс, который ведет себя как список. В вопросе памяти range эффективнее, чем использование актуального списка чисел.

import sys

myreallist = [x for x in range(0, 10000)]
print(sys.getsizeof(myreallist))
# 87632
****************************************************************************************************
Использование * и ** для распаковки аргументов функций

Некоторые функции требуют длинного списка аргументов. Этого следует избегать (например, с помощью классов данных), хотя это не всегда зависит от вас. Существует другой вариант – создать словарь с именованными аргументами и передать его функции. Так ваш код станет более читабельным.

Распаковать словарь можно, используя префикс **:        
>>> def f(a, b):
...     print(a, b)
...
>>> args = { "a": 1, "b": 2 }
>>> f(**args)
1 2

Аналогично можно использовать * для распаковки массива и передачи его содержимого в качестве аргументов функции:
>>> def f(a, b, c):
...    print(a, b, c)
...
>>> l = [1, 2, 3]
>>> f(*l)
1 2 3
****************************************************************************************************
Строка – заголовок

Если хотите быстро получить красивый заголовок, сделайте так:
mystring = "10 awesome python tricks"
print(mystring.title())
'10 Awesome Python Tricks'
****************************************************************************************************
Разбиение строки в список

Вы можете разбить строку на список строк. В этом случае разбиение происходит по символу пробела:        
mystring = "The quick brown fox"
mylist = mystring.split(' ')
print(mylist)
# ['The', 'quick', 'brown', 'fox']

Чтобы разделить по пустому месту, не нужно передавать в split никаких аргументов – используйте mystring.split().

Split также имеет второй параметр, называемый maxsplit, который определяет максимальное количество разбиений. По умолчанию он равен -1 (без ограничений). Вот пример, с ограничением разбиения на 1:
>>> mystring.split(' ', 1)
['The', 'quick brown fox']
****************************************************************************************************
Создание строки из списка строк

Создание строки из списка и установка пробелов между каждым словом:
mylist = ['The', 'quick', 'brown', 'fox']
mystring = " ".join(mylist)
print(mystring)
# 'The quick brown fox'

Все сводится к тому, что функция String.join() может присоединять не только списки, но и любой iterable. Помещение его внутрь строки предотвращает реализацию одной и той же функциональности в нескольких местах.
****************************************************************************************************
Query JSON

JMESpath – это язык запросов для JSON, который позволяет получать необходимые данные из документа или словаря JSON. Библиотека доступна как для Python, так и для других ЯП, что расширяет ее возможности.

Вот несколько примеров кода для общего представления:
>>> import jmespath
>>> persons = {
...   "persons": [
...     { "name": "erik", "age": 38 },
...     { "name": "john", "age": 45 },
...     { "name": "rob", "age": 14 }
...   ]
... }
>>> jmespath.search('persons[*].age', persons)
[38, 45, 14]
****************************************************************************************************
Реверс строк и списков

Вы можете использовать slice-нотацию, чтобы перевернуть строку или список. При отрицательном значении шага, элементы меняются местами:
revstring = "abcdefg"[::-1]
print(revstring)
# 'gfedcba'

revarray = [1, 2, 3, 4, 5][::-1]
print(revarray)
# [5, 4, 3, 2, 1]
****************************************************************************************************
Получение уникальных элементов из списка или строки

Создавая набор с помощью функции set(), вы получаете все уникальные элементы из списка или объекта:
mylist = [1, 1, 2, 3, 4, 5, 5, 5, 6, 6]
print (set(mylist))
# {1, 2, 3, 4, 5, 6}

# And since a string can be treated like a 
# list of letters, you can also get the 
# unique letters from a string this way:
print (set("aaabbbcccdddeeefff"))
# {'a', 'b', 'c', 'd', 'e', 'f'}
****************************************************************************************************
Валидные значения словаря

В словарь можно поместить что угодно – вы не ограничены числами или строками. Можете поместить списки внутрь словаря и получить доступ к вложенным значениям:
>>> a = { 'sub_dict': { 'b': True }, 'mylist': [100, 200, 300] }
>>> a['sub_dict']['b']
True
>>> a['mylist'][0]
100
****************************************************************************************************
Тернарный оператор условного присваивания

Это еще один способ сделать код более кратким и сохранить его читабельность:        
[on_true] if [expression] else [on_false]

А вот пример:
x = "Success!" if (y == 2) else "Failed!"
****************************************************************************************************
Подсчет вхождений в список

Используйте Counter из библиотеки коллекций, чтобы получить словарь с подсчетом всех уникальных элементов в списке:
        
from collections import Counter

mylist = [1, 1, 2, 3, 4, 5, 5, 5, 6, 6]
c = Counter(mylist)
print(c)
# Counter({1: 2, 2: 1, 3: 1, 4: 1, 5: 3, 6: 2})

# And it works on strings too:
print(Counter("aaaaabbbbbccccc"))
# Counter({'a': 5, 'b': 5, 'c': 5})
****************************************************************************************************
Цепочки операторов сравнения

Создавайте еще более читаемый и аккуратный код:

x = 10

# Instead of:
if x > 5 and x < 15:
    print("Yes")
# yes

# You can also write:
if 5 < x < 15:
    print("Yes")
# Yes
****************************************************************************************************
Работа с датами

Модуль python-dateutil предоставляет мощное расширение для стандартного datetime. Устанавливается он следующим образом:
pip3 install python-dateutil

Вот пример парсинга даты из логов:
        
from dateutil.parser import parse

logline = 'INFO 2020-01-01T00:00:01 Happy new year, human.'
timestamp = parse(logline, fuzzy=True)
print(timestamp)
# 2020-01-01 00:00:01
****************************************************************************************************
Использование map()

Такой синтаксис имеет данная встроенная функция:        
map(function, something_iterable)

Ниже видите пример с использованием списков:
def upper(s):
    return s.upper()
    
mylist = list(map(upper, ['sentence', 'fragment']))
print(mylist)
# ['SENTENCE', 'FRAGMENT']

# Convert a string representation of
# a number into a list of ints.
list_of_ints = list(map(int, "1234567"))
print(list_of_ints)
# [1, 2, 3, 4, 5, 6, 7]
****************************************************************************************************
Словарь и set comprehensions

Словарю нужны ключ и значение:        
>>> {x: x**2 for x in (2, 4, 6)}
{2: 4, 4: 16, 6: 36}

Определяем ключ и значение в expression.

Синтаксис set comprehension не сильно отличается от list comprehension. Мы просто используем фигурные скобки вместо квадратных:
{ <expression> for item in list if <conditional> }

Пример:
>>> {s for s in range(1,5) if s % 2}
{1, 3}
****************************************************************************************************

****************************************************************************************************
